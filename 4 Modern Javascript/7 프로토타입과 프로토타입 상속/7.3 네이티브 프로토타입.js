/* 모든 내장 객체는 같은 패턴을 따름
메서드는 프로토타입에 저장됩니다(Array.prototype, Object.prototype, Date.prototype 등).
객체 자체엔 데이터만 저장(배열의 요소, 객체의 프로퍼티, 날짜 등) */


/* 내장 프로토타입을 수정할 수 있음.
내장 프로토타입의 메서드를 빌려와 새로운 메서드를 만드는 것 역시 가능
그러나 내장 프로토타입 변경은 되도록 하지 않아야 함 *****
내장 프로토타입은 새로 명세서에 등록된 기능을 사용하고 싶은데 자바스크립트 엔진엔 이 기능이 구현되어있지 않을 때만 변경하는 게 좋음

모던 프로그래밍에서 네이티브 프로토타입 변경을 허용하는 경우는 딱 하나뿐. 바로 폴리필을 만들 때. ******
폴리필은 자바스크립트 명세서에 있는 메서드와 동일한 기능을 하는 메서드 구현체를 의미. 명세서에는 정의되어 있으나 특정 자바스크립트 엔진에서는 해당 기능이 구현되어있지 않을 때 폴리필을 사용.

폴리필을 직접 구현하고 난 후 폴리필을 내장 프로토타입에 추가할 때만 네이티브 프로토타입을 변경 */

예시:

if (!String.prototype.repeat) { // repeat이라는 메서드가 없다고 가정
  // 프로토타입에 repeat를 추가

  String.prototype.repeat = function(n) {    // string을 n회 반복(repeat)

    // 실제 이 메서드를 구현하려면 코드는 더 복잡해질것
    // 전체 알고리즘은 명세서에서 확인할 수 있음
    // 그런데 완벽하지 않은 폴리필이라도 충분히 유용함
    return new Array(n + 1).join(this);
  };
}

alert( "La".repeat(3) ); // LaLaLa


//--------------------------------------------------------------------------------------------------------------
과제예시1; // 메서드 "f.defer(ms)"를 함수에 추가하기
// 모든 함수의 프로토타입에 ms밀리초 후에 함수를 실행하는 defer(ms)함수를 추가해보자: 

Function.prototype.defer = function(ms) {
    setTimeout(this, ms);
}

function f() {
    alert("Hello");
}

f.defer(1000); // 1초 후 "Hello!" 출력