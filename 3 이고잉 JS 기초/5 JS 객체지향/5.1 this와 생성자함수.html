<script>
    let Mymath = {              //객체를 사용하지 않고 개발은 불가능(Math.도 객체)
        PI:Math.PI,             //객체 속 변수 PI      
        random:function(){      //객체 속 함수(메서드)
            return Math.random();
        },
        floor:function(val){
            return Math.floor(val);
        }
    }
    document.write("Mymath.Pi = ", Mymath.PI+'<br>');
    document.write("Mymath.random = ", Mymath.random()+'<br>');
    document.write("Mymath.floor = ", Mymath.floor(3.9)+'<br>');
</script>


* this = this가 속해있는 객체를 가르키도록 약속된 예약어
<script>
let ko = {
    name:'Ko',
    first:75,
    second:82,
    sum:function(f, s){ //함수 속 두 값을 입력받아야함. 그 후 연산
        return f+s;
    },
    sum2:function(){    
        return this.first + this.second;  // ko.first + ko.second와 같은것 (this=ko)
    }
}
document.write("ko.sum = "+ ko.sum(ko.first, ko.second)); //객체 안에 객체 호출 = 비효율적(시간)
document.write("ko.sum = "+ ko.sum2());                   //this로 효율적
</script>


* Constructor Function (생성자 함수) (객체를 찍어내는 공장을 만드는 constructor 함수)  
<script>
    function Person(name,first,second,third){
    this.name = name;                    // 객체의 속성들(변수들)은 생성자 함수 안에 넣는 것이 일반적
    this.first = first;
    this.second = second;
    this.third = third;
    }
    Person.prototype.sum = function(){   // 객체의 메소드들은 생성자의 prototype에 추가하는 것이 일반적 (메모리 절약)
        return this.first+this.second+this.third;
    }
let kim = new Person('kim',10,20,30); // new 라는 키워드를 붙이므로 위 person 함수가 객체를 찍어내는 생성자(constructor)이 됨
let lee = new Person('lee',10,10,10);
let ko = Person('ko',10,30,30);     //그냥 함수 호출 = 일반 함수 취급 = undefined

document.write('kim.sum()', kim.sum()+'<br>');  
document.write('lee.sum()', lee.sum());
document.write('ko.sum()', ko.sum()+'<br>');  //객체 생성 X = undefined
</script> 

